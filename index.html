<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>그노시아 시뮬레이터</title>

  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <style>
    :root{
      --bg:#0f0f10;
      --panel:#151517;
      --panel2:#0b0b0c;
      --txt:#e9e9ea;
      --muted:#a6a6aa;
      --line:#2a2a2e;
      --accent:#78d7ff;
      --bad:#ff6b6b;
      --ok:#7CFF9B;
      --warn:#ffd26b;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; padding:16px;
      background:var(--bg); color:var(--txt);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }
    h1{ margin:0 0 10px; font-size:28px; letter-spacing:0.5px; }
    h2{ margin:14px 0 8px; font-size:16px; }
    h3{ margin:10px 0 6px; font-size:13px; color:var(--muted); font-weight:700; }

    .wrap{ max-width:1200px; margin:0 auto; display:grid; gap:12px; }
    .card{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border-radius: 12px;
      padding: 12px;
    }

    .row{ display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end; }
    .field{ flex: 1 1 220px; min-width: 180px; }
    .label{ display:block; font-size:12px; color:var(--muted); margin:0 0 4px; }

    input, select, button{
      font: inherit;
      font-size: 13px;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--txt);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }
    input:focus, select:focus{ border-color: var(--accent); }

    button{ cursor:pointer; background:#17171a; }
    button:hover{ border-color: var(--accent); }
    button:disabled{ cursor:not-allowed; opacity:.45; }

    fieldset{
      margin: 10px 0 0;
      padding: 10px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(0,0,0,0.16);
    }
    legend{
      padding: 0 8px;
      color: var(--muted);
      font-size: 12px;
      font-weight: 700;
    }

    .kv-grid{
      display:grid;
      gap: 8px;
      grid-template-columns: repeat(6, minmax(120px, 1fr));
    }
    @media (max-width: 1100px){ .kv-grid{ grid-template-columns: repeat(3, minmax(120px, 1fr)); } }
    @media (max-width: 700px){ .kv-grid{ grid-template-columns: repeat(2, minmax(120px, 1fr)); } }

    .kv{
      border:1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      padding: 8px 10px;
    }
    .kv .k{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:center;
    }
    .kv .k .hint{ color:#8c8c90; font-size: 11px; }
    .kv input{ width:100%; max-width:none; }

    .cmd-grid{
      display:grid;
      gap: 6px 10px;
      grid-template-columns: repeat(4, minmax(190px, 1fr));
    }
    @media (max-width: 1100px){ .cmd-grid{ grid-template-columns: repeat(3, minmax(190px, 1fr)); } }
    @media (max-width: 800px){ .cmd-grid{ grid-template-columns: repeat(2, minmax(190px, 1fr)); } }
    @media (max-width: 560px){ .cmd-grid{ grid-template-columns: 1fr; } }

    .cmd{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 6px 8px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(0,0,0,0.14);
    }
    .cmd input{ width:16px; height:16px; }
    .cmd .name{ font-size: 13px; }
    .cmd .req{ margin-left:auto; font-size:11px; color:#8c8c90; white-space:nowrap; }
    .cmd.disabled{ opacity:.42; }

    .toolbar{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-top: 10px; }
    .toolbar input[type="file"]{ padding: 6px 8px; max-width: 280px; }

    .two-col{ display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 1000px){ .two-col{ grid-template-columns: 1fr; } }

    #charList, #log{
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(0,0,0,0.18);
      padding: 10px;
      overflow:auto;
      height: 320px;
    }
    #log{ background:#000; }

    .char-entry{
      border:1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      padding: 8px 10px;
      margin-bottom: 8px;
      font-size: 12px;
      line-height: 1.45;
    }
    .char-entry .top{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      margin-bottom: 6px;
    }
    .char-entry .top b{ font-size: 13px; }
    .char-entry .mini{ color: var(--muted); font-size: 11px; }

    .char-actions{ display:flex; gap:6px; align-items:center; }
    .btn-mini{
      padding: 6px 8px;
      font-size: 12px;
      border-radius: 10px;
    }
    .btn-warn{ border-color: rgba(255,107,107,0.6); }
    .btn-warn:hover{ border-color: var(--bad); }

    .logline{ margin:0 0 6px; }
    .tag{ color: var(--accent); }
    .bad{ color: var(--bad); }
    .ok{ color: var(--ok); }
    .warn{ color: var(--warn); }
    .note{ font-size: 12px; color: var(--muted); margin-top: 8px; }

    .edit-banner{
      margin-top: 10px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px dashed rgba(120,215,255,0.6);
      color: var(--muted);
      background: rgba(120,215,255,0.06);
      display:none;
    }
    .edit-banner b{ color: var(--accent); }

    .settings-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(240px, 1fr));
      gap:10px;
      align-items:start;
    }
    @media (max-width: 900px){ .settings-grid{ grid-template-columns: 1fr; } }

    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.18);
      font-size: 12px;
      color: var(--muted);
      margin-right:6px;
      margin-bottom:6px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>그노시아 시뮬레이터</h1>

    <div class="card">
      <h2>게임 설정</h2>
      <div class="settings-grid">
        <div>
          <h3>역할 사용 여부</h3>
          <label class="pill"><input type="checkbox" id="optEngineer" checked> 엔지니어</label>
          <label class="pill"><input type="checkbox" id="optDoctor" checked> 닥터</label>
          <label class="pill"><input type="checkbox" id="optGuardian" checked> 수호천사</label>
          <label class="pill"><input type="checkbox" id="optStandby"> 선내대기인(2명 고정)</label>
          <label class="pill"><input type="checkbox" id="optAC" checked> AC주의자</label>
          <label class="pill"><input type="checkbox" id="optBug" checked> 버그</label>

          <div class="note">
            ※ 선원/그노시아는 항상 포함. 선내대기인은 체크 시 <b>2명</b>이 반드시 배정됩니다.
          </div>
        </div>

        <div>
          <h3>그노시아 수</h3>
          <div class="row">
            <div class="field">
              <span class="label">그노시아 수(자동 상한 적용)</span>
              <input id="gnosiaCount" type="number" min="1" step="1" value="1" />
            </div>
          </div>
          <div class="note" id="gnosiaHint"></div>
        </div>

        <div>
          <h3>시뮬레이터 안내</h3>
          <div class="note">
            - 실행 버튼: <b>낮 5턴</b> → <b>밤 2단계</b> 진행<br/>
            - 게임 시작 시 <b>역할이 유저에게 공개</b>됩니다.<br/>
            - 거짓말 탐지(직감): 누가 누군가의 사칭/거짓말을 눈치채면 로그에 출력됩니다.<br/>
            - <b>역할을 밝혀라</b>: “아직 커밍아웃 안 된 역할”이 있을 때만 사용됩니다. 또한 <b>같은 역할은 하루 1회</b>만 요구됩니다.
          </div>
        </div>
      </div>
    </div>

    <div class="card" id="createCard">
      <h2>캐릭터 생성</h2>

      <div class="row">
        <div class="field">
          <span class="label">이름</span>
          <input id="name" placeholder="이름" />
        </div>
        <div class="field">
          <span class="label">성별</span>
          <select id="gender">
            <option value="남성">남성</option>
            <option value="여성">여성</option>
            <option value="범성">범성</option>
          </select>
        </div>
        <div class="field">
          <span class="label">식별연령</span>
          <input id="age" type="number" min="0" step="1" value="20" />
        </div>
      </div>

      <fieldset>
        <legend>스테이터스 (0~50)</legend>
        <div class="kv-grid" id="statsGrid"></div>
      </fieldset>

      <fieldset>
        <legend>성격 (0.00~1.00)</legend>
        <div class="kv-grid" id="persGrid"></div>
      </fieldset>

      <fieldset>
        <legend>사용 가능한 커맨드 선택 (체크)</legend>
        <div class="cmd-grid" id="commandList"></div>
        <div class="note">
          ※ 스테이터스 조건을 충족하지 못하는 커맨드는 <b>선택 불가</b>(회색 처리).<br/>
          성향상 “절대 쓰지 않을” 커맨드는 체크를 해제하세요.
        </div>
      </fieldset>

      <div class="toolbar">
        <button id="addChar">캐릭터 추가</button>
        <button id="applyEditBtn" disabled style="display:none;">수정 적용</button>
        <button id="cancelEditBtn" disabled style="display:none;">수정 취소</button>

        <button id="runBtn" disabled>실행</button>
        <button id="saveBtn">세이브</button>
        <input type="file" id="loadFile" accept=".json" />
        <button id="loadBtn">로드</button>
      </div>

      <div class="edit-banner" id="editBanner">
        <span>현재 <b>캐릭터 수정 모드</b>입니다. 수정 후 <b>수정 적용</b>을 누르세요.</span>
      </div>

      <div class="note">실행 버튼은 캐릭터 <b>5명 이상</b>부터 활성화됩니다.</div>
    </div>

    <div class="two-col">
      <div class="card">
        <h2>캐릭터 목록</h2>
        <div id="charList"></div>
      </div>

      <div class="card">
        <h2>게임 로그</h2>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <script>
    const STAT_FIELDS = [
      { key:"charisma", label:"카리스마", hint:"0~50", step:"0.1", min:0, max:50 },
      { key:"logic", label:"논리력", hint:"0~50", step:"0.1", min:0, max:50 },
      { key:"acting", label:"연기력", hint:"0~50", step:"0.1", min:0, max:50 },
      { key:"charm", label:"귀염성", hint:"0~50", step:"0.1", min:0, max:50 },
      { key:"stealth", label:"스텔스", hint:"0~50", step:"0.1", min:0, max:50 },
      { key:"intuition", label:"직감", hint:"0~50", step:"0.1", min:0, max:50 },
    ];

    const PERS_FIELDS = [
      { key:"cheer", label:"쾌활함", hint:"0~1", step:"0.01", min:0, max:1 },
      { key:"social", label:"사회성", hint:"0~1", step:"0.01", min:0, max:1 },
      { key:"logical", label:"논리성향", hint:"0~1", step:"0.01", min:0, max:1 },
      { key:"kindness", label:"상냥함", hint:"0~1", step:"0.01", min:0, max:1 },
      { key:"desire", label:"욕망", hint:"0~1", step:"0.01", min:0, max:1 },
      { key:"courage", label:"용기", hint:"0~1", step:"0.01", min:0, max:1 },
    ];

    const COMMANDS = [
      { name:"의심한다", req:[] },
      { name:"의심에 동의한다", req:[] },
      { name:"부정한다", req:[] },
      { name:"변호한다", req:[] },
      { name:"변호에 가담한다", req:[] },
      { name:"감싼다", req:[] },
      { name:"함께 감싼다", req:[] },
      { name:"감사한다", req:[] },
      { name:"반론한다", req:[] },
      { name:"반론에 가담한다", req:[] },
      { name:"시끄러워", req:[] },
      { name:"역할을 밝힌다", req:[] },
      { name:"자신도 밝힌다", req:[] },
      { name:"역할을 밝혀라", req:[["charisma",10]] },
      { name:"과장해서 말한다", req:[["acting",15]] },
      { name:"동의를 구한다", req:[["charisma",25]] },
      { name:"반론을 막는다", req:[["charisma",40]] },
      { name:"얼버무린다", req:[["stealth",25]] },
      { name:"반격한다", req:[["logic",25],["acting",25]] },
      { name:"도움을 요청한다", req:[["acting",30]] },
      { name:"슬퍼한다", req:[["charm",25]] },
      { name:"속지마라", req:[["intuition",30]] },
      { name:"투표해라", req:[["logic",10]] },
      { name:"투표하지 마라", req:[["logic",15]] },
      { name:"반드시 인간이다", req:[["logic",20]] },
      { name:"반드시 적이다", req:[["logic",20]] },
      { name:"전원 배제해라", req:[["logic",30]] },
      { name:"잡담한다", req:[["stealth",10]] },
      { name:"협력하자", req:[["charm",15]] },
      { name:"인간이라고 말해", req:[["intuition",20]] },
      { name:"도게자한다", req:[["stealth",35]] },
      { name:"밤:협력요청", req:[] },
    ];

    const el = (id)=>document.getElementById(id);
    const logBox = el("log");
    function addLog(text, cls=""){
      const p = document.createElement("p");
      p.className = "logline " + cls;
      p.textContent = text;
      logBox.appendChild(p);
      logBox.scrollTop = logBox.scrollHeight;
    }

    function clamp(n, min, max){
      if(Number.isNaN(n)) return min;
      return Math.min(max, Math.max(min, n));
    }
    function readNumber(id, min, max){
      const v = (document.getElementById(id).value ?? "").toString().trim();
      const n = parseFloat(v);
      return clamp(n, min, max);
    }

    let characters = [];
    let editingIndex = null;

    function buildKVGrid(containerId, fields, defaultValue){
      const g = document.getElementById(containerId);
      g.innerHTML = "";
      fields.forEach(f=>{
        const box = document.createElement("div");
        box.className = "kv";
        box.innerHTML = `
          <div class="k">
            <span>${f.label}</span>
            <span class="hint">${f.hint}</span>
          </div>
          <div class="v">
            <input id="${f.key}" type="number" min="${f.min}" max="${f.max}" step="${f.step}" value="${defaultValue}" />
          </div>
        `;
        g.appendChild(box);
      });
    }
    buildKVGrid("statsGrid", STAT_FIELDS, 0);
    buildKVGrid("persGrid", PERS_FIELDS, 0);

    const cmdList = el("commandList");
    function buildCommandChecks(){
      cmdList.innerHTML = "";
      COMMANDS.forEach(cmd=>{
        const row = document.createElement("label");
        row.className = "cmd";

        const reqText = cmd.req.length
          ? cmd.req.map(([k,v])=>{
              const label = STAT_FIELDS.find(s=>s.key===k)?.label ?? k;
              return `${label}≥${v}`;
            }).join(", ")
          : "조건없음";

        row.innerHTML = `
          <input type="checkbox" data-cmd="${cmd.name}">
          <span class="name">${cmd.name}</span>
          <span class="req">${reqText}</span>
        `;
        cmdList.appendChild(row);
      });
    }
    buildCommandChecks();

    function getCurrentStats(){
      const stats = {};
      STAT_FIELDS.forEach(f=>{
        const val = readNumber(f.key, f.min, f.max);
        stats[f.key] = val;
      });
      return stats;
    }

    function refreshCommandAvailability(){
      const stats = getCurrentStats();
      const rows = cmdList.querySelectorAll(".cmd");
      rows.forEach(row=>{
        const checkbox = row.querySelector("input[type=checkbox]");
        const name = checkbox.dataset.cmd;
        const cmd = COMMANDS.find(c=>c.name===name);

        if(name.startsWith("밤:")){
          checkbox.disabled = false;
          row.classList.toggle("disabled", false);
          return;
        }

        let ok = true;
        for(const [k,v] of cmd.req){
          if((stats[k] ?? 0) < v){ ok = false; break; }
        }
        checkbox.disabled = !ok;
        row.classList.toggle("disabled", !ok);
        if(!ok) checkbox.checked = false;
      });
    }

    STAT_FIELDS.forEach(f=>{
      el(f.key).addEventListener("input", refreshCommandAvailability);
    });
    refreshCommandAvailability();

    const charList = el("charList");

    function renderCharacters(){
      charList.innerHTML = "";
      characters.forEach((c, idx)=>{
        const div = document.createElement("div");
        div.className = "char-entry";
        const cmdCount = c.allowedCommands.length;

        div.innerHTML = `
          <div class="top">
            <b>#${idx+1} ${c.name}</b>
            <div class="char-actions">
              <button class="btn-mini" data-edit="${idx}">수정</button>
              <button class="btn-mini btn-warn" data-del="${idx}">삭제</button>
            </div>
          </div>
          <div class="mini">${c.gender} · ${c.age}세</div>
          <div class="mini">스테이터스: 카리스마 ${c.stats.charisma} / 논리력 ${c.stats.logic} / 연기력 ${c.stats.acting} / 귀염성 ${c.stats.charm} / 스텔스 ${c.stats.stealth} / 직감 ${c.stats.intuition}</div>
          <div class="mini">성격: 쾌활함 ${c.pers.cheer} / 사회성 ${c.pers.social} / 논리성향 ${c.pers.logical} / 상냥함 ${c.pers.kindness} / 욕망 ${c.pers.desire} / 용기 ${c.pers.courage}</div>
          <div class="mini">사용 커맨드(${cmdCount}): ${cmdCount ? c.allowedCommands.join(", ") : "없음"}</div>
        `;
        charList.appendChild(div);
      });

      charList.querySelectorAll("button[data-del]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const idx = parseInt(btn.dataset.del, 10);
          const name = characters[idx]?.name ?? "해당 캐릭터";
          if(confirm(`${name} 을(를) 삭제할까요?`)){
            if(editingIndex === idx) exitEditMode(true);
            characters.splice(idx, 1);
            addLog(`[삭제] ${name} 삭제됨`, "bad");
            renderCharacters();
            updateGnosiaLimitUI();
          }
        });
      });

      charList.querySelectorAll("button[data-edit]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const idx = parseInt(btn.dataset.edit, 10);
          enterEditMode(idx);
        });
      });

      el("runBtn").disabled = characters.length < 5;
    }

    function collectFormCharacter(){
      const name = el("name").value.trim();
      const gender = el("gender").value;
      const age = clamp(parseInt(el("age").value,10), 0, 999);

      if(!name){ alert("이름을 입력하세요."); return null; }
      if(Number.isNaN(age)){ alert("식별연령을 올바르게 입력해주세요."); return null; }

      const stats = {};
      STAT_FIELDS.forEach(f=>{
        const v = readNumber(f.key, f.min, f.max);
        stats[f.key] = Math.round(v*10)/10;
      });

      const pers = {};
      PERS_FIELDS.forEach(f=>{
        const v = readNumber(f.key, f.min, f.max);
        pers[f.key] = Math.round(v*100)/100;
      });

      const allowed = [];
      cmdList.querySelectorAll("input[type=checkbox]").forEach(chk=>{
        if(chk.checked && !chk.disabled) allowed.push(chk.dataset.cmd);
      });

      return { name, gender, age, stats, pers, allowedCommands: allowed };
    }

    function clearCommandChecks(){
      cmdList.querySelectorAll("input[type=checkbox]").forEach(chk=>{ chk.checked = false; });
    }

    function enterEditMode(idx){
      const c = characters[idx];
      if(!c) return;

      editingIndex = idx;
      el("editBanner").style.display = "block";
      el("applyEditBtn").style.display = "";
      el("cancelEditBtn").style.display = "";
      el("applyEditBtn").disabled = false;
      el("cancelEditBtn").disabled = false;
      el("addChar").disabled = true;

      el("name").value = c.name;
      el("gender").value = c.gender;
      el("age").value = c.age;

      STAT_FIELDS.forEach(f=>{ el(f.key).value = c.stats[f.key] ?? 0; });
      PERS_FIELDS.forEach(f=>{ el(f.key).value = c.pers[f.key] ?? 0; });

      refreshCommandAvailability();
      clearCommandChecks();
      const set = new Set(c.allowedCommands);
      cmdList.querySelectorAll("input[type=checkbox]").forEach(chk=>{
        if(!chk.disabled && set.has(chk.dataset.cmd)) chk.checked = true;
      });

      addLog(`[수정 모드] ${c.name} 편집 중...`, "tag");
      el("createCard").scrollIntoView({behavior:"smooth", block:"start"});
    }

    function exitEditMode(silent=false){
      editingIndex = null;
      el("editBanner").style.display = "none";
      el("applyEditBtn").style.display = "none";
      el("cancelEditBtn").style.display = "none";
      el("applyEditBtn").disabled = true;
      el("cancelEditBtn").disabled = true;
      el("addChar").disabled = false;
      clearCommandChecks();
      refreshCommandAvailability();
      if(!silent) addLog("[수정 모드] 취소됨", "tag");
    }

    el("cancelEditBtn").addEventListener("click", ()=> exitEditMode(false));

    el("applyEditBtn").addEventListener("click", ()=>{
      if(editingIndex === null) return;
      const updated = collectFormCharacter();
      if(!updated) return;

      const prevName = characters[editingIndex]?.name ?? "";
      characters[editingIndex] = updated;
      addLog(`[수정 완료] ${prevName} → ${updated.name}`, "ok");
      renderCharacters();
      exitEditMode(true);
    });

    el("addChar").addEventListener("click", ()=>{
      const c = collectFormCharacter();
      if(!c) return;

      characters.push(c);
      addLog(`[캐릭터 추가] ${c.name} 생성 완료`, "ok");
      renderCharacters();
      clearCommandChecks();
      updateGnosiaLimitUI();
    });

    el("saveBtn").addEventListener("click", ()=>{
      const data = JSON.stringify(characters, null, 2);
      const blob = new Blob([data], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "gnosia_characters.json";
      a.click();
      URL.revokeObjectURL(url);
      addLog("[세이브] 캐릭터 목록 저장 완료", "ok");
    });

    el("loadBtn").addEventListener("click", ()=>{
      const file = el("loadFile").files?.[0];
      if(!file){ alert("로드할 파일을 선택하세요."); return; }
      const r = new FileReader();
      r.onload = ()=>{
        try{
          const parsed = JSON.parse(r.result);
          if(!Array.isArray(parsed)) throw new Error("형식이 올바르지 않음");
          characters = parsed;
          exitEditMode(true);
          renderCharacters();
          updateGnosiaLimitUI();
          addLog("[로드] 캐릭터 목록 불러오기 완료", "ok");
        }catch(e){
          alert("로드 실패: 파일 형식이 올바르지 않습니다.");
        }
      };
      r.readAsText(file);
    });

    function maxGnosiaByCount(n){
      if(n<=6) return 1;
      if(n<=8) return 2;
      if(n<=10) return 3;
      if(n<=12) return 4;
      if(n<=14) return 5;
      return 6;
    }
    function updateGnosiaLimitUI(){
      const n = characters.length;
      const mx = maxGnosiaByCount(Math.max(5, n));
      const input = el("gnosiaCount");
      input.max = String(mx);
      input.min = "1";
      const cur = parseInt(input.value,10);
      if(Number.isNaN(cur) || cur<1) input.value = "1";
      if(parseInt(input.value,10) > mx) input.value = String(mx);
      el("gnosiaHint").textContent = `현재 인원(${n}명) 기준 그노시아 최대: ${mx}명`;
    }
    el("gnosiaCount").addEventListener("input", updateGnosiaLimitUI);
    updateGnosiaLimitUI();

    const ROLE = {
      CREW: "선원",
      GNOSIA: "그노시아",
      ENGINEER: "엔지니어",
      DOCTOR: "닥터",
      GUARDIAN: "수호천사",
      STANDBY: "선내대기인",
      AC: "AC주의자",
      BUG: "버그",
    };

    const game = {
      started:false,
      day:1,
      phase:"day",
      dayTurn:0,
      nightStep:0,
      aliveIds:new Set(),
      roles:new Map(),
      claims:new Map(),
      coDoneToday:new Set(),      // “캐릭터당” 오늘 CO 1회 제한(Q3)
      roleAskUsedToday:new Set(), // ★ “역할별” 오늘 role_ask 1회 제한(추가)
      roleAskRole:null,
      blockDefense:false,
      attackProtectedId:null,
    };

    function buildRuntimeChars(){
      return characters.map((c, idx)=>({ id: String(idx), ...c }));
    }
    function pickOne(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function shuffle(arr){
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }

    function enabledSettings(){
      return {
        engineer: el("optEngineer").checked,
        doctor: el("optDoctor").checked,
        guardian: el("optGuardian").checked,
        standby: el("optStandby").checked,
        ac: el("optAC").checked,
        bug: el("optBug").checked,
        gnosiaCount: clamp(parseInt(el("gnosiaCount").value,10), 1, maxGnosiaByCount(Math.max(5, characters.length))),
      };
    }

    function canFakeRole(realRole, claimRole){
      if(claimRole === ROLE.ENGINEER || claimRole === ROLE.DOCTOR){
        return (realRole === ROLE.GNOSIA || realRole === ROLE.AC);
      }
      if(claimRole === ROLE.STANDBY) return false;
      return false;
    }

    function initGame(){
      const rt = buildRuntimeChars();
      game.started = true;
      game.day = 1;
      game.phase = "day";
      game.dayTurn = 0;
      game.nightStep = 0;
      game.aliveIds = new Set(rt.map(x=>x.id));
      game.roles = new Map();
      game.claims = new Map();
      game.coDoneToday = new Set();
      game.roleAskUsedToday = new Set();
      game.roleAskRole = null;
      game.blockDefense = false;
      game.attackProtectedId = null;

      const opt = enabledSettings();
      const n = rt.length;

      const rolesToAssign = [];
      if(opt.standby && n >= 6) rolesToAssign.push(ROLE.STANDBY, ROLE.STANDBY);
      if(opt.bug) rolesToAssign.push(ROLE.BUG);
      if(opt.ac) rolesToAssign.push(ROLE.AC);
      if(opt.engineer) rolesToAssign.push(ROLE.ENGINEER);
      if(opt.doctor) rolesToAssign.push(ROLE.DOCTOR);
      if(opt.guardian) rolesToAssign.push(ROLE.GUARDIAN);
      for(let i=0;i<opt.gnosiaCount;i++) rolesToAssign.push(ROLE.GNOSIA);
      while(rolesToAssign.length > n) rolesToAssign.pop();

      const ids = shuffle(rt.map(x=>x.id));

      ids.forEach(id=>{
        game.roles.set(id, ROLE.CREW);
        game.claims.set(id, null);
      });

      // standby 먼저 고정
      if(opt.standby && n >= 6){
        const standbyIds = ids.slice(0,2);
        standbyIds.forEach(id=> game.roles.set(id, ROLE.STANDBY));
        // rolesToAssign에서 standby 2개 제거
        let removed = 0;
        for(let i=rolesToAssign.length-1;i>=0;i--){
          if(rolesToAssign[i] === ROLE.STANDBY){
            rolesToAssign.splice(i,1);
            removed++;
            if(removed===2) break;
          }
        }
      }

      const remainingIds = ids.filter(id=>game.roles.get(id) !== ROLE.STANDBY);
      const shuffledRoles = shuffle(rolesToAssign.filter(r=>r!==ROLE.STANDBY));
      for(let i=0;i<shuffledRoles.length && i<remainingIds.length;i++){
        game.roles.set(remainingIds[i], shuffledRoles[i]);
      }

      addLog(`=== 게임 시작: 역할 배정(유저에게 공개) ===`, "tag");
      rt.forEach(ch=>{
        addLog(`${ch.name} : ${game.roles.get(ch.id)}`, "ok");
      });
      addLog(`(낮 5턴 진행 후 밤으로 이동)`, "tag");
    }

    function getAliveRuntime(){
      const rt = buildRuntimeChars();
      return rt.filter(x=>game.aliveIds.has(x.id));
    }

    // ★ “아직 커밍아웃 안 된 역할들”만 반환 (없으면 [])
    function getUnclaimedRoles(){
      const opt = enabledSettings();
      const enabledCO = [];
      if(opt.engineer) enabledCO.push(ROLE.ENGINEER);
      if(opt.doctor) enabledCO.push(ROLE.DOCTOR);
      if(opt.standby) enabledCO.push(ROLE.STANDBY);

      if(!enabledCO.length) return [];

      const claimed = new Set();
      for(const cr of game.claims.values()){
        if(cr) claimed.add(cr);
      }
      return enabledCO.filter(r=>!claimed.has(r));
    }

    // (A) 아직 CO 안 된 역할 중 랜덤 선택, 없으면 null
    function pickRoleAskRole(){
      const notYet = getUnclaimedRoles();
      if(!notYet.length) return null;
      return pickOne(notYet);
    }

    function processLieDetection(liarId, claimRole){
      const liarRole = game.roles.get(liarId);
      const isLie = (claimRole && claimRole !== liarRole);
      if(!isLie) return;

      const alive = getAliveRuntime();
      const liar = alive.find(x=>x.id===liarId);
      if(!liar) return;

      alive.forEach(obs=>{
        if(obs.id === liarId) return;
        const intu = obs.stats.intuition ?? 0;
        const acting = liar.stats.acting ?? 0;
        const base = (intu - acting*0.6);
        const p = clamp(base / 60, 0, 0.85);
        if(Math.random() < p){
          addLog(`※ ${obs.name}가 ${liar.name}의 거짓말을 눈치챘다.`, "warn");
        }
      });
    }

    function canUseCommand(charObj, cmdName){
      if(!charObj.allowedCommands.includes(cmdName)) return false;
      if(cmdName.startsWith("밤:") && game.phase === "day") return false;
      if(cmdName.startsWith("밤:") && game.phase === "night") return true;

      const cmd = COMMANDS.find(c=>c.name===cmdName);
      if(!cmd) return false;
      for(const [k,v] of cmd.req){
        if((charObj.stats[k] ?? 0) < v) return false;
      }
      return true;
    }

    function doTurn_RoleAsk(speaker){
      // ★ 규칙 1: “아직 CO 안 된 역할”이 없으면 아예 사용 불가
      const askRole = pickRoleAskRole();
      if(!askRole){
        // 여긴 원래 들어오지 않게 설계(선택 자체를 안 하니까)
        return;
      }

      // ★ 규칙 2: 같은 역할 role_ask는 “하루 1회만”
      if(game.roleAskUsedToday.has(askRole)){
        return;
      }
      game.roleAskUsedToday.add(askRole);

      game.roleAskRole = askRole;
      game.blockDefense = false;
      addLog(`${speaker.name}:[역할을 밝혀라] ${askRole} 역할은 밝혀라.`, "tag");

      const alive = getAliveRuntime();
      const responders = alive.filter(c=>c.id!==speaker.id);

      const coCandidates = [];
      responders.forEach(p=>{
        if(game.coDoneToday.has(p.id)) return; // 캐릭터당 오늘 CO 1회

        const real = game.roles.get(p.id);

        let canCO = false;
        if(real === askRole) canCO = true;
        else if(canFakeRole(real, askRole)) canCO = true;

        if(!canCO) return;

        const courage = p.pers.courage ?? 0;
        const base = 0.15 + courage * 0.55;
        const bonus = (real === askRole) ? 0.20 : 0.00;
        const prob = clamp(base + bonus, 0, 0.90);

        if(Math.random() < prob){
          coCandidates.push({ who:p, claimRole: askRole });
        }
      });

      if(!coCandidates.length){
        addLog(`(아무도 ${askRole} 역할을 밝히지 않았다.)`, "");
        return;
      }

      const reveals = shuffle(coCandidates).slice(0, 2);
      reveals.forEach(({who, claimRole})=>{
        game.claims.set(who.id, claimRole);
        game.coDoneToday.add(who.id);
        addLog(`${who.name}:[역할을 밝힌다] (자신이 ${claimRole}라고 선언한다.)`, "tag");
        processLieDetection(who.id, claimRole);
      });

      const follow = [];
      getAliveRuntime().forEach(p=>{
        if(p.id===speaker.id) return;
        if(game.coDoneToday.has(p.id)) return;

        const real = game.roles.get(p.id);
        let canCO = false;
        if(real === askRole) canCO = true;
        else if(canFakeRole(real, askRole)) canCO = true;
        if(!canCO) return;

        const courage = p.pers.courage ?? 0;
        const base = 0.08 + courage * 0.40;
        const bonus = (real === askRole) ? 0.18 : 0.00;
        const prob = clamp(base + bonus, 0, 0.75);

        if(Math.random() < prob){
          follow.push(p);
        }
      });

      if(follow.length){
        const picked = shuffle(follow).slice(0, 2);
        picked.forEach(p=>{
          game.claims.set(p.id, askRole);
          game.coDoneToday.add(p.id);
          addLog(`${p.name}:[자신도 밝힌다] (나도 ${askRole}라고 선언한다.)`, "tag");
          processLieDetection(p.id, askRole);
        });
      }
    }

    function runDayOneTurn(){
      const alive = getAliveRuntime();
      if(alive.length < 2){
        addLog("진행 불가: 생존 인원이 부족합니다.", "bad");
        return;
      }

      game.roleAskRole = null;
      game.blockDefense = false;

      // “낮 첫 턴” = 하루 시작 시, 오늘 제한 초기화
      if(game.dayTurn === 0){
        game.coDoneToday.clear();
        game.roleAskUsedToday.clear(); // ★ 추가: 역할별 role_ask 오늘 1회 제한
      }

      // 발언자 선택(스텔스 낮을수록 튀어나옴)
      const weighted = [];
      alive.forEach(c=>{
        const stealth = c.stats.stealth ?? 0;
        const w = clamp((55 - stealth) / 10, 1, 8);
        for(let i=0;i<w;i++) weighted.push(c);
      });
      const speaker = pickOne(weighted);

      // ★ “역할을 밝혀라”는 ‘가능’ + ‘요구할 역할 존재’ + ‘그 역할이 오늘 아직 안 나옴’일 때만 고려
      const askRole = pickRoleAskRole(); // 없으면 null
      const canRoleAsk = askRole && canUseCommand(speaker, "역할을 밝혀라") && !game.roleAskUsedToday.has(askRole);

      if(canRoleAsk){
        const courage = speaker.pers.courage ?? 0;
        const cha = speaker.stats.charisma ?? 0;
        const p = clamp(0.10 + courage*0.25 + (cha/50)*0.25, 0.10, 0.55);
        if(Math.random() < p){
          // doTurn_RoleAsk 내부에서 askRole을 다시 뽑지만,
          // 여기서도 조건을 보장해뒀기 때문에 실제 사용 확률이 안정적임
          doTurn_RoleAsk(speaker);
          return;
        }
      }

      addLog(`${speaker.name}:[의심한다] (임시) 누군가 수상해.`, "");
    }

    function nightFreeActions(){
      const alive = getAliveRuntime();
      if(alive.length < 1){
        addLog("밤 자유행동: 생존 인원이 없습니다.", "bad");
        return;
      }

      const coopUsers = alive.filter(c=>c.allowedCommands.includes("밤:협력요청"));
      const events = Math.min(3, Math.max(1, Math.floor(Math.random()*3)+1));

      for(let i=0;i<events;i++){
        const doCoop = coopUsers.length && Math.random() < 0.45;
        if(doCoop){
          const a = pickOne(coopUsers);
          let b = pickOne(alive);
          if(a.id===b.id) b = pickOne(alive);

          const charm = a.stats.charm ?? 0;
          const social = b.pers.social ?? 0;
          const p = clamp(0.35 + (charm/50)*0.25 + social*0.25, 0.05, 0.85);
          if(Math.random() < p){
            addLog(`밤 자유행동: ${a.name}는 ${b.name}에게 협력 요청을 했고, 협력에 성공했다.`, "ok");
          }else{
            addLog(`밤 자유행동: ${a.name}는 ${b.name}에게 협력 요청을 했지만, 거절당했다.`, "warn");
          }
        }else{
          if(alive.length >= 2 && Math.random() < 0.6){
            const a = pickOne(alive);
            let b = pickOne(alive);
            if(a.id===b.id) b = pickOne(alive);
            addLog(`밤 자유행동: ${a.name}는 ${b.name}와 함께 시간을 보냈다. (임시: 우호도 상승)`, "");
          }else{
            const a = pickOne(alive);
            addLog(`밤 자유행동: ${a.name}는 혼자서 시간을 보냈다.`, "");
          }
        }
      }
    }

    function guardianProtect(){
      const alive = getAliveRuntime();
      const guardians = alive.filter(c=>game.roles.get(c.id)===ROLE.GUARDIAN);
      if(!guardians.length) return null;

      const g = pickOne(guardians);
      const targets = alive.filter(x=>x.id !== g.id);
      if(!targets.length) return null;
      const t = pickOne(targets);
      game.attackProtectedId = t.id;
      addLog(`(수호천사: ${g.name}가 누군가를 보호했다.)`, "tag");
      return t.id;
    }

    function gnosiaAttack(){
      const alive = getAliveRuntime();
      const gnosias = alive.filter(c=>game.roles.get(c.id)===ROLE.GNOSIA);
      if(!gnosias.length){
        addLog("밤 습격: 그노시아가 없다.", "warn");
        return [];
      }

      const scored = alive
        .filter(x=>game.roles.get(x.id)!==ROLE.GNOSIA)
        .map(c=>{
          const s = c.stats;
          const p = c.pers;
          const score =
            (50 - (s.stealth ?? 0)) * 0.9 +
            (s.logic ?? 0) * 0.6 +
            (p.desire ?? 0) * 8 +
            (s.charisma ?? 0) * 0.25;
          return { c, score };
        })
        .sort((a,b)=>b.score-a.score);

      if(!scored.length){
        addLog("밤 습격: 대상이 없습니다.", "warn");
        return [];
      }

      const target = scored[0].c;

      if(game.attackProtectedId && target.id === game.attackProtectedId){
        addLog("밤 습격: 아무도 소멸하지 않았습니다.", "ok");
        return [];
      }

      const role = game.roles.get(target.id);
      if(role === ROLE.BUG){
        addLog("밤 습격: 아무도 소멸하지 않았습니다.", "ok");
        return [];
      }

      game.aliveIds.delete(target.id);
      addLog(`밤 습격: ${target.name}이(가) 그노시아에 의해 소멸했습니다.`, "bad");
      return [target.id];
    }

    el("runBtn").addEventListener("click", ()=>{
      if(characters.length < 5){
        alert("캐릭터가 5명 이상이어야 실행할 수 있습니다.");
        return;
      }
      if(!game.started){
        initGame();
      }

      if(game.phase === "day"){
        game.dayTurn++;
        addLog(`낮 ${game.day}일차 - 턴 ${game.dayTurn}/5`, "tag");
        runDayOneTurn();

        if(game.dayTurn >= 5){
          game.phase = "night";
          game.nightStep = 0;
          addLog("낮이 종료되었습니다. 밤으로 넘어갑니다.", "tag");
        }
        return;
      }

      if(game.phase === "night"){
        game.nightStep++;

        if(game.nightStep === 1){
          addLog(`밤 ${game.day}일차 1/2: 자유행동`, "tag");
          nightFreeActions();
          return;
        }

        if(game.nightStep === 2){
          addLog(`밤 ${game.day}일차 2/2: 역할 집행/습격`, "tag");
          game.attackProtectedId = null;
          guardianProtect();
          gnosiaAttack();

          game.day++;
          game.phase = "day";
          game.dayTurn = 0;
          game.nightStep = 0;
          addLog("밤이 종료되었습니다. 다음 날로 넘어갑니다.", "tag");
          return;
        }
      }
    });

    addLog("로드 완료. 캐릭터를 5명 이상 만들고 실행 버튼을 눌러주세요.", "ok");
    renderCharacters();
    updateGnosiaLimitUI();
  </script>
</body>
</html>
